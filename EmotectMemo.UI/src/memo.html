<!DOCTYPE html>

<html  x-data="theme()" x-init="init()" :class="mode"  lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script defer src="./js/alpine.min.js"></script>
    <link href="./css/styles.css" rel="stylesheet">
    <!-- <script src="https://cdn.tailwindcss.com"></script> -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Montserrat&display=swap');
    </style>
    <script>
        const baseURL =`http://localhost:62000${window.location.pathname}`;
        const welcomeMessage = 'I\'ll remember what you said in a protected way. You remember the Emoword, the only key. Remember me.'
        const Memos = ()=>{
            const emoCrypt = new Crypto();
            return {
                key: "",
                content: [],
                hasContent: false,
                isLoading: true,
                emoword: "",
                decrypted: false,
                init() {
                    fetch(`${baseURL}/exists`)
                        .then(response => response.json())
                        .then(response => {
                            this.isLoading = false;
                            this.hasContent = response.exists;
                            this.key = window.location.pathname;
                        })
                        .catch((exception) => {
                            console.log(exception);
                        });
                },
                get isNewPage(){
                    return !this.isLoading && !this.hasContent;
                },
                get canShowContent(){
                    return !this.isLoading && this.content != null && this.decrypted;
                },
                async post(memo) {
                    if (!memo)
                    {
                        memo = welcomeMessage;
                    }
                    await emoCrypt.setPassword(this.emoword);
                    (async () => {
                        const rawResponse = await fetch(baseURL, {
                            method: 'POST',
                            headers: {
                                'Accept': 'application/json',
                                'Content-Type': 'application/json',
                                'Secret-Key' : emoCrypt.secretKey
                            },
                            body: JSON.stringify({ body: await emoCrypt.encrypt(memo) })
                        });
                        const response = await rawResponse;
                        if (response){
                            await this.getPage();
                        }
                        console.log(response);
                    })();
                },
                async getPage(){
                    await emoCrypt.setPassword(this.emoword);
                    (async () => {
                        const rawResponse = await fetch(baseURL, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                                'Content-Type': 'application/json',
                                'Secret-Key' : emoCrypt.secretKey
                            }});
                        const response = await rawResponse.json();
                        for (let i = 0; i < response.content.length; i++) {
                            debugger;
                            const c = response.content[i]
                            this.content = [];
                            this.content.push({
                                id: c.id,
                                body: await emoCrypt.decrypt(c.body)
                            });
                        }
                        this.decrypted = true;
                        console.log(response);
                    })();
                }
            };
        }

        const darkModeLocalStorageKey = 'darkMode';
        const theme = ()=>{
            return {
                darkMode: false,
                init(){
                    this.darkMode=localStorage.getItem(darkModeLocalStorageKey)=='true';
                },
                get mode(){
                    return this.darkMode?'dark':'';
                },
                get otherModeEmoji(){
                    return this.darkMode?'☀️':'🌙'
                },
                toggleMode(){
                    this.darkMode = !this.darkMode;
                    localStorage.setItem(darkModeLocalStorageKey, this.darkMode);
                }
            }
        }

        const Crypto = class {
            #password;
            #encryptionKey;
            #secretKey;
            constructor(){
            }

            static async Create(password)
            {
                const crypto = new Crypto();
                await crypto.setPassword(password);
                return crypto;
            }

            async setPassword(password){
                if (password != this.#password)
                {
                    this.#password = password;
                    this.#encryptionKey = await this.createEncryptionKey(this.#password);
                    this.#secretKey = await this.createSecretKey(this.#encryptionKey);
                }
            }

            get secretKey(){
                return this.#secretKey;
            }

            encode(text){
                const encoder = new TextEncoder();
                return encoder.encode(text);
            }
            async digestSHA256(message){
                const data = this.encode(message);
                return await window.crypto.subtle.digest("SHA-256", data);
            }

            async createEncryptionKey(password){
                return await this.digestSHA256(password);
            }

            async createSecretKey(encryptionKey){
                //We need a unique key to set as password in the server 
                //  to make sure the user has correct Emoword and to 
                //  be sure that the Emoword is not retrievable having
                //  this key.
                //Therefor SHA of Half of SHA string of the Emoword is used as the key.
                const keybase = this.arrayBufferToString(encryptionKey);
                const halfOfKey = keybase.substring(0, Math.floor(keybase.length/2)+1);
                const secretKeyBuff = await this.digestSHA256(halfOfKey);
                return btoa(this.arrayBufferToString(secretKeyBuff));
            }

            arrayBufferToString(arraybuffer){
                const hashArray = Array.from(new Uint8Array(arraybuffer));
                return hashArray.map(byte => String.fromCharCode(byte)).join('');
            }
            stringToUint8Array(text){
                return new Uint8Array(Array.from(text).map(ch => ch.charCodeAt(0))); 
            }

            async encrypt(plainText){
                const encoded = this.encode(plainText);

                const iv = crypto.getRandomValues(new Uint8Array(12));  
                const algorithm = { name: "AES-GCM", iv: iv };
                const key = await crypto.subtle.importKey('raw', 
                    this.#encryptionKey, algorithm, false, ['encrypt']);

                    const encrypted = await window.crypto.subtle.encrypt(
                    algorithm,
                    key,
                    encoded,
                );

                const encryptedMessage =btoa(
                    this.arrayBufferToString(iv) + 
                    this.arrayBufferToString(encrypted));
                debugger;
                return encryptedMessage;
            }

            async decrypt(encryptedMessage){
                const encrypted = atob(encryptedMessage);
                const iv = this.stringToUint8Array(encrypted.slice(0,12));
                const message = this.stringToUint8Array(encrypted.slice(12));

                const algorithm = { name: "AES-GCM", iv: iv };
                const key = await crypto.subtle.importKey('raw', 
                    this.#encryptionKey, algorithm, false, ['decrypt']);

                try {
                    const plainBuff = await crypto.subtle.decrypt(
                        algorithm, 
                        key, 
                        message);  
                    return this.arrayBufferToString(plainBuff);
                } catch (error) {
                    return "Failed to decrypt message."
                }
            }
        }

    </script>
    <title>EmotectMemo</title>
</head>
<body class="transition-all duration-200 dark:bg-emotral-100 bg-emotral-2 flex flex-col items-center w-screen h-dvh font-body text-xs  text-emotral-100 dark:text-emotral-2 ">
    <div class="flex flex-col flex-nowrap grid-cols-1 grid-rows-1 
        items-end content-stretch justify-start justify-items-start 
        min-w-80 h-dvh w-full gap-4">

    <div class="justify-between-row items-center gap-4 pr-3 pl-3 pt-4 pb-4">
        <button class="emoji-button" @click="toggleMode()" x-text="otherModeEmoji">🌘</button>
        <h1 class="flex-shrink-0 font-semibold text-sm">
            Emotect Memo
        </h1>         
    </div>
    <div x-data="Memos()" x-init="init()" class="flex flex-col flex-nowrap items-center content-stretch justify-end 
        gap-8 self-center w-full pl-3 pr-3">
        <!-- group: Illustation_Create -->
        <template x-if="isLoading">
            <div>Loading...</div>
        </template>
        <template x-if="!isLoading">
            <div>
                <img :src="darkMode?'img/wand-dark.svg':'img/wand.svg'" width="164" height="164" />
            </div>
        </template>
        <template x-if="isNewPage">
            <div x-data="{step: 'emoword'}" class="card">
                <div class="text-start" x-show="step == 'emoword'">   
                    <p class="flex flex-row">
                        It's an empty or a new EmotectMemo page, the decision is yours to make. 
                    </p>
                    <p class="flex flex-row">
                        EmotectMemo is a minimal end to end encrypted text sharing app, protected by Emoji passwords. Set the Emoword and own it.
                    </p>
                </div>
                <div class="over-input-label" x-show="step == 'emoword'">
                    <label class="flex flex-row" for="emoword">
                        Make your Emoword
                    </label>
                    <input x-init="$nextTick(() => $el.focus())" class="emoword-text"
                        type="text" name="emoword" x-model="emoword" placeholder="Example: 🥲🍁☃️😌">
                    </input>
                </div>
                <button :disabled="emoword==''" class="primary-button" @click="step='confirm'" x-show="step == 'emoword'">
                    Set Emoword
                </button>

                <div class="text-start" x-show="step == 'confirm'">   
                    <h2 class="flex flex-row font-semibold">
                        Remember! Remember!
                    </h2>
                    <p class="flex flex-row">
                        Once the Emoword is made for this page, it would be used as an end to end encryption key and you would be the only one who knows it. Remember it. There would be no recovery available.
                    </p>
                </div>
                <div class="flex row items-center content-stretch justify-between gap-1 h-auto w-full" x-show="step == 'confirm'">
                    <label class="flex flex-row items-start content-stretch gap-1" for="copyEmoji" x-text="`Current Emoword: ${emoword}`"></label>
                    <button name="copyEmoji" class="emoji-button" @click="navigator.clipboard.writeText(emoword);">📑</button>
                </div>
                <div class="justify-between-row gap-6 items-start" x-show="step == 'confirm'">
                    <button class="primary-button" @click="post()">
                        Looks Good
                    </button>
                    <button class="secondary-button" @click="step='emoword'">
                        Change Emoword
                    </button>
                </div>

            </div>
        </template>
        <template x-if="canShowContent">
            <strong x-text="content"></strong>
        </template>
      </div>
</div>  
</body>
</html>